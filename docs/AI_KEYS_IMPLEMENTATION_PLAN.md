# План реализации: отдельное сохранение ключей Gemini и OpenAI

## Проблема

При сохранении ключей API оба поля (Gemini и OpenAI) отправлялись одним запросом. При нажатии «Сохранить ключ» под одним провайдером в теле запроса уходили оба ключа: введённый — с значением, второй — пустой. Бэкенд обновлял оба провайдера: один — новым ключом, второй — пустым значением (`null`), из‑за чего «определялся» только один ключ.

## Решение

1. **Фронтенд**: у каждого провайдера своя кнопка «Сохранить ключ»; при нажатии отправляется только ключ этого провайдера (в теле только `gemini` или только `openai`).
2. **Бэкенд**: обновляется только тот провайдер, который передан в запросе; ключ записывается только если значение не пустое (`filled()`), чтобы случайная пустая строка не затирала сохранённый ключ.

---

## Внесённые изменения

### 1. Backend: `App\Http\Controllers\Api\AiKeysController::updateKeys`

- **Было**: при наличии в запросе ключа `gemini` или `openai` вызывался `setKey()`; пустая строка трактовалась как «очистить ключ», из‑за чего при отправке обоих полей второй ключ сбрасывался.
- **Стало**:
  - Обновляется только тот провайдер, для которого ключ передан в запросе (`has('gemini')` / `has('openai')`).
  - Запись в БД выполняется только при непустом значении: `$request->filled('gemini')` / `$request->filled('openai')`. Пустая строка не обновляет ключ и не затирает существующий.
  - В ответе возвращается сообщение с указанием, какой ключ сохранён (например: «Ключ Gemini сохранён.» / «Ключ OpenAI сохранён.»).

### 2. Frontend: `resources/js/pages/admin/AiKeysPage.vue`

- **Кнопки**: у блока Gemini и у блока OpenAI свои кнопки «Сохранить ключ»; каждая вызывает `saveKey('gemini')` или `saveKey('openai')`.
- **Функция `saveKey(provider)`**:
  - Формирует тело запроса только с одним ключом: `{ gemini: keys.gemini }` или `{ openai: keys.openai }`.
  - Отправляет `PUT /api/ai/keys` с этим телом.
  - Состояние загрузки и сообщения сделаны по провайдеру: `savingKeys.gemini` / `savingKeys.openai`, `keysSuccess.gemini` / `keysSuccess.openai`, `keysError.gemini` / `keysError.openai`.
- **Отображение**: сообщение об успехе или ошибке выводится под соответствующим блоком (Gemini или OpenAI).

---

## Поведение после исправления

| Действие | Запрос | Результат |
|----------|--------|-----------|
| Нажатие «Сохранить ключ» в блоке Gemini | `PUT /api/ai/keys` с телом `{ "gemini": "AlzaSy..." }` | Обновляется только ключ Gemini; ключ OpenAI не меняется. |
| Нажатие «Сохранить ключ» в блоке OpenAI | `PUT /api/keys` с телом `{ "openai": "sk-proj-..." }` | Обновляется только ключ OpenAI; ключ Gemini не меняется. |
| Пустое поле + сохранение | Например `{ "gemini": "" }` | Ключ Gemini не перезаписывается (backend не обновляет при пустом значении). |

Оба ключа могут быть установлены и сохраняются независимо друг от друга.

---

## Чек-лист для проверки

- [ ] Сохранение ключа Gemini не сбрасывает ключ OpenAI.
- [ ] Сохранение ключа OpenAI не сбрасывает ключ Gemini.
- [ ] Сообщение «Ключ Gemini сохранён.» появляется только под блоком Gemini.
- [ ] Сообщение «Ключ OpenAI сохранён.» появляется только под блоком OpenAI.
- [ ] При ошибке API сообщение об ошибке показывается под тем блоком, в котором нажали «Сохранить ключ».
- [ ] После успешного сохранения маска текущего ключа обновляется (после перезагрузки данных с сервера).
